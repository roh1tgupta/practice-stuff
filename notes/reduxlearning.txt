when it makes sense to use Redux:
You have reasonable amounts of data changing over time
You need a single source of truth for your state
You find that keeping all your state in a top-level component is no longer sufficient

Redux can be described in three fundamental principles:
Single source of truth: The state of your whole application is stored in an object tree within a single store
State is read-only: The only way to change the state is to emit an action, an object describing what happened.
Changes are made with pure functions: To specify how the state tree is transformed by actions, you write pure reducers.

Actions: Actions are payloads of information that send data from your application to your store.
They are the only source of information for the store.
Actions are plain JavaScript objects. Actions must have a type property that indicates the type of action being performed.
You send them to the store using store.dispatch().

Reducers specify how the application's state changes in response to actions sent to the store. 
Things you should never do inside a reducer:
Mutate its arguments;
Perform side effects like API calls and routing transitions;
Call non-pure functions, e.g. Date.now() or Math.random().

Actions that represent the facts about “what happened” and the reducers that update the state according to those actions.
The Store is the object that brings them together. The store has the following responsibilities:
Holds application state;
Allows access to state via getState();
Allows state to be updated via dispatch(action);
Registers listeners via subscribe(listener);
Handles unregistering of listeners via the function returned by subscribe(listener).

It's important to note that you'll only have a single store in a Redux application.
When you want to split your data handling logic, you'll use reducer composition instead of many stores.

You may optionally specify the initial state as the second argument to createStore().
This is useful for hydrating the state of the client to match the state of a Redux application running on the server.

const store = createStore(todoApp, window.STATE_FROM_SERVER)

// Note that subscribe() returns a function for unregistering the listener
const unsubscribe = store.subscribe(() => console.log(store.getState()));

// Stop listening to state updates
unsubscribe()

// Log the initial state
console.log(store.getState())

// Dispatch some actions
store.dispatch(addTodo('Learn about actions'))


Redux architecture revolves around a strict unidirectional data flow.
This means that all data in an application follows the same lifecycle pattern,
making the logic of your app more predictable and easier to understand. It also encourages data normalization,
so that you don't end up with multiple, independent copies of the same data that are unaware of one another.

The data lifecycle in any Redux app follows these 4 steps:
1>You call store.dispatch(action).
2>The Redux store calls the reducer function you gave it: The store will pass two arguments to
the reducer: the current state tree and the action. 
3>The root reducer may combine the output of multiple reducers into a single state tree.
4>The Redux store saves the complete state tree returned by the root reducer.
This new tree is now the next state of your app! Every listener registered with
store.subscribe(listener) will now be invoked; listeners may call store.getState() to get the current state.


					Presentational Components					Container Components
Purpose				How things look (markup, styles)			How things work (data fetching, state updates)
Aware of Redux		No											Yes
To read data		Read data from props						Subscribe to Redux state
To change data		Invoke callbacks from props					Dispatch Redux actions
Are written			By hand										Usually generated by React Redux



Technically you could write the container components by hand using store.subscribe().
We don't advise you to do this because React Redux makes many performance optimizations that
are hard to do by hand. For this reason, rather than write container components, we will generate them using the connect();


